#include <stdio.h>
#define cheng 5
int main(void)
{
	int kkk;
	char zik[28]={'a','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
	int a,b,c,d;
	char zi;
	int fan[28];
	while(1)
	{
	printf("请输入任意英文字母:");
	scanf(" %c",&zi);
	printf("大写字母的ascii范围%d~%d\n",'A','Z');
	printf("小写字母的ascii范围%d~%d\n",'a','z');
	if(zi>=65 && zi<=90)
	{
		zi=zi;
		break;
	}
	else if(zi>=97 && zi<=122)
	{
		zi=zi-32;
		break;
	}
	else
	{
		printf("您输入的不是26个英文字母之1,请重新输入!\n");
		continue;
	}
	}

	for(kkk=1;kkk<28;kkk++)
	{
		if(zi==zik[kkk])
		{
			printf("高度为%d(层)\n",kkk);
			break;
		}

	}
	for(a=1;a<=kkk;a++)//这个5是因为输入的是e,而a,b,c,d,e.e刚好是第五个.
	{
		for(b=0;b<kkk-a;b++)//打印空格数
			printf(" ");
		for(b=0,c=65;b<a;b++,c++)//打印前面的字符
		{
			printf("%c",c);
		}
		int stored_count = 0; // 记录实际存储的元素个数
		for(b=0,c=65;b<a-1;b++,c++)//打印后面的字符
		{//这个循环的作用是储存一个数组.
			fan[b]=c;
			stored_count++; // 每存储一个，计数器加1
			//关键是先把要打印的原始字符按顺序放入一个数组中,然后反向打印这数组中的字符;//不能多打印,也不能少打印.
		}

		// 反向打印实际存储的元素
       		 for(int i = stored_count - 1; i >= 0; i--)
        	{
           		 printf("%c", fan[i]);
        	}
		printf("\n");//换行
	}
//思考一下来,
//
//比如说,for(int x=0,int c=65,y=0;x<5;x++,c++,)
//        {
//           text[x]=c;//c是数字.数字必需要按某种规律变化.
//        }




       // for(int jk=65;jk<=90;jk++)
//	printf("%c\n",jk);
//处理这类问题,最重要的是把握关系,打印金字塔要把握行数与每一行的空格与字符数的关系.
//所以,把握事物与事物之间的联系是很重要的.
//关键在于定义好条件表达式.
    return 0;
}
//第一次循环打印出了预期的结果,但是第二次循环却出了问题.
//第二次循环,a=2
//
//思考一下,
//第一次循环.a=1,c=65,1<5成立,第一个内循环没有问题,第二个内循环没问题,0<1成立,打印出A,然后,b++,c++,b=1,c=66,1<1不成立,退出循环,第三个内循环,b=0,0<1-1不成立,跳过循环体,打印换行符,然后,a++,c--,a=2,c=65.
//第二次循环,a=2,c=65,2<成立,第二个内循环,b=0,0<2成立.打印字符A,然后b++,c++,b=1,c=66,1<2成立,打印字符B,然后b++,c++,b=2,c=67,因为2<2不成立.所以推出循环.第三个内循环,0<2-1成立,现在问题解决,但是又出现了新的问题.问题出现在第三个内循环.
//
//
//我懂了,用户的输入完全没有被用上啊!
//现在改进了一下,但是第二个内循环和第三个内循环还是有问题
//
//
//分析一下来,
//
//
//用一个数组储存它,然后反向打印!
//
//这就是解决第三个内循环的真理!.
